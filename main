#!/usr/bin/env bash
set -euo pipefail

### Vortex MC Control Plane Installer (Custom Dashboard + Provisioning Scaffold)
### Target: Ubuntu 22.04 (root). Domain: dashboard.vortexhosting.onl
### Backend: Pterodactyl already exists (configure in Admin UI after install)

DOMAIN_DEFAULT="dashboard.vortexhosting.onl"
INSTALL_DIR="/opt/vortex-mc"
APP_PORT="3000"

log() { echo -e "[vortex] $*"; }
die() { echo -e "[vortex][error] $*" >&2; exit 1; }

require_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    die "Run as root (sudo -i) then retry."
  fi
}

require_ubuntu_2204() {
  if [[ ! -f /etc/os-release ]]; then die "Cannot detect OS."; fi
  . /etc/os-release
  if [[ "${ID:-}" != "ubuntu" ]]; then
    die "This installer supports Ubuntu only. Detected: ${ID:-unknown}"
  fi
  if [[ "${VERSION_ID:-}" != "22.04" ]]; then
    die "This installer targets Ubuntu 22.04. Detected: ${VERSION_ID:-unknown}"
  fi
}

need_cmd() { command -v "$1" >/dev/null 2>&1; }

install_packages() {
  log "Installing base packages..."
  apt-get update -y
  apt-get install -y curl ca-certificates gnupg lsb-release ufw openssl git
}

install_docker() {
  if need_cmd docker; then
    log "Docker is already installed."
    return
  fi

  log "Installing Docker..."
  install -m 0755 -d /etc/apt/keyrings
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
  chmod a+r /etc/apt/keyrings/docker.gpg

  . /etc/os-release
  echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
    ${VERSION_CODENAME} stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null

  apt-get update -y
  apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
  systemctl enable --now docker
}

configure_firewall() {
  log "Configuring firewall (UFW): allow SSH, 80, 443..."
  ufw allow OpenSSH >/dev/null || true
  ufw allow 80/tcp >/dev/null || true
  ufw allow 443/tcp >/dev/null || true
  ufw --force enable >/dev/null || true
}

rand_b64_32() {
  openssl rand -base64 32 | tr -d '\n'
}

write_files() {
  local domain="${1:-$DOMAIN_DEFAULT}"
  log "Creating install directory at ${INSTALL_DIR}..."
  mkdir -p "${INSTALL_DIR}"
  chmod 700 "${INSTALL_DIR}"

  log "Generating secrets..."
  local SETTINGS_MASTER_KEY
  local SESSION_SECRET
  SETTINGS_MASTER_KEY="$(rand_b64_32)"
  SESSION_SECRET="$(rand_b64_32)"

  # .env (not printed to console)
  cat > "${INSTALL_DIR}/.env" <<EOF
# Core
DOMAIN=${domain}
APP_PORT=${APP_PORT}

# Database
POSTGRES_DB=vortex
POSTGRES_USER=vortex
POSTGRES_PASSWORD=$(openssl rand -hex 24)

# Redis
REDIS_URL=redis://redis:6379

# App secrets
SETTINGS_MASTER_KEY=${SETTINGS_MASTER_KEY}
SESSION_SECRET=${SESSION_SECRET}

# Optional: set APP_BASE_URL if behind a proxy with a different public URL
APP_BASE_URL=https://${domain}
EOF
  chmod 600 "${INSTALL_DIR}/.env"

  log "Writing docker-compose.yml, Caddyfile, and app sources..."
  mkdir -p "${INSTALL_DIR}/caddy" "${INSTALL_DIR}/db" "${INSTALL_DIR}/app" "${INSTALL_DIR}/worker"

  cat > "${INSTALL_DIR}/docker-compose.yml" <<'EOF'
services:
  postgres:
    image: postgres:16-alpine
    restart: unless-stopped
    env_file: .env
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - ./db/data:/var/lib/postgresql/data
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 3s
      retries: 20

  redis:
    image: redis:7-alpine
    restart: unless-stopped
    command: ["redis-server", "--appendonly", "yes"]
    volumes:
      - ./db/redis:/data

  app:
    build: ./app
    restart: unless-stopped
    env_file: .env
    environment:
      - DATABASE_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      - REDIS_URL=${REDIS_URL}
      - SETTINGS_MASTER_KEY=${SETTINGS_MASTER_KEY}
      - SESSION_SECRET=${SESSION_SECRET}
      - APP_BASE_URL=${APP_BASE_URL}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    expose:
      - "3000"

  worker:
    build: ./worker
    restart: unless-stopped
    env_file: .env
    environment:
      - DATABASE_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      - REDIS_URL=${REDIS_URL}
      - SETTINGS_MASTER_KEY=${SETTINGS_MASTER_KEY}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started

  caddy:
    image: caddy:2-alpine
    restart: unless-stopped
    env_file: .env
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./caddy/Caddyfile:/etc/caddy/Caddyfile:ro
      - ./caddy/data:/data
      - ./caddy/config:/config
    depends_on:
      - app
EOF

  cat > "${INSTALL_DIR}/caddy/Caddyfile" <<EOF
${domain} {
  encode gzip zstd
  reverse_proxy app:3000
}
EOF

  # DB init
  cat > "${INSTALL_DIR}/db/init.sql" <<'EOF'
create table if not exists users (
  id uuid primary key default gen_random_uuid(),
  email text unique not null,
  password_hash text not null,
  role text not null default 'owner',
  created_at timestamptz not null default now()
);

create table if not exists app_settings (
  id boolean primary key default true,
  discord_client_id text,
  discord_client_secret_enc text,
  discord_enabled boolean not null default false,
  ptero_url text,
  ptero_app_api_key_enc text,
  ptero_enabled boolean not null default false,
  updated_at timestamptz not null default now(),
  updated_by_user_id uuid
);

insert into app_settings (id) values (true)
on conflict (id) do nothing;

create table if not exists audit_log (
  id bigserial primary key,
  actor_user_id uuid not null,
  action text not null,
  fields_changed text[] not null,
  created_at timestamptz not null default now(),
  ip inet,
  user_agent text
);

-- enable gen_random_uuid()
create extension if not exists pgcrypto;
EOF

  # App: package + server
  cat > "${INSTALL_DIR}/app/package.json" <<'EOF'
{
  "name": "vortex-mc-dashboard",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.6",
    "dotenv": "^16.4.5",
    "ejs": "^3.1.10",
    "express": "^4.19.2",
    "express-session": "^1.17.3",
    "pg": "^8.12.0",
    "connect-redis": "^8.0.2",
    "redis": "^4.6.14"
  }
}
EOF

  cat > "${INSTALL_DIR}/app/Dockerfile" <<'EOF'
FROM node:20-alpine
WORKDIR /app
COPY package.json package-lock.json* ./
RUN npm install --omit=dev
COPY . .
EXPOSE 3000
CMD ["npm", "run", "start"]
EOF

  cat > "${INSTALL_DIR}/app/server.js" <<'EOF'
import express from "express";
import session from "express-session";
import cookieParser from "cookie-parser";
import bcrypt from "bcryptjs";
import { Pool } from "pg";
import { createClient } from "redis";
import connectRedis from "connect-redis";
import crypto from "crypto";

const app = express();
app.set("view engine", "ejs");
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.use(cookieParser());

const DATABASE_URL = process.env.DATABASE_URL;
const REDIS_URL = process.env.REDIS_URL;
const SETTINGS_MASTER_KEY_B64 = process.env.SETTINGS_MASTER_KEY;
const SESSION_SECRET = process.env.SESSION_SECRET || "change-me";
const APP_BASE_URL = process.env.APP_BASE_URL || "http://localhost";

if (!DATABASE_URL) throw new Error("DATABASE_URL missing");
if (!REDIS_URL) throw new Error("REDIS_URL missing");
if (!SETTINGS_MASTER_KEY_B64) throw new Error("SETTINGS_MASTER_KEY missing");

const masterKey = Buffer.from(SETTINGS_MASTER_KEY_B64, "base64");
if (masterKey.length < 32) throw new Error("SETTINGS_MASTER_KEY must be >= 32 bytes base64");

const pool = new Pool({ connectionString: DATABASE_URL });

const RedisStore = connectRedis(session);
const redis = createClient({ url: REDIS_URL });
await redis.connect();

app.use(session({
  store: new RedisStore({ client: redis }),
  secret: SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: { httpOnly: true, sameSite: "lax", secure: true }
}));

function encryptSecret(plaintext) {
  const iv = crypto.randomBytes(12);
  const key = masterKey.subarray(0, 32);
  const cipher = crypto.createCipheriv("aes-256-gcm", key, iv);
  const enc = Buffer.concat([cipher.update(plaintext, "utf8"), cipher.final()]);
  const tag = cipher.getAuthTag();
  return `${iv.toString("base64")}:${tag.toString("base64")}:${enc.toString("base64")}`;
}

function decryptSecret(stored) {
  const [ivB64, tagB64, dataB64] = stored.split(":");
  const iv = Buffer.from(ivB64, "base64");
  const tag = Buffer.from(tagB64, "base64");
  const data = Buffer.from(dataB64, "base64");
  const key = masterKey.subarray(0, 32);
  const decipher = crypto.createDecipheriv("aes-256-gcm", key, iv);
  decipher.setAuthTag(tag);
  const dec = Buffer.concat([decipher.update(data), decipher.final()]);
  return dec.toString("utf8");
}

async function ensureAdminUser() {
  // If no users exist, create a default owner user and print creds ONCE to container logs.
  const { rows } = await pool.query("select count(*)::int as c from users");
  if (rows[0].c === 0) {
    const email = "admin@local";
    const pass = crypto.randomBytes(12).toString("base64url");
    const hash = await bcrypt.hash(pass, 12);
    await pool.query("insert into users (email, password_hash, role) values ($1,$2,'owner')", [email, hash]);
    console.log("====================================================");
    console.log("VORTEX DASHBOARD INITIAL ADMIN CREATED");
    console.log(`Login URL: ${APP_BASE_URL}/login`);
    console.log(`Email: ${email}`);
    console.log(`Password: ${pass}`);
    console.log("Change this password immediately after login.");
    console.log("====================================================");
  }
}
await ensureAdminUser();

function requireAuth(req, res, next) {
  if (!req.session.user) return res.redirect("/login");
  next();
}
function requireAdmin(req, res, next) {
  if (!req.session.user) return res.redirect("/login");
  const role = req.session.user.role;
  if (role !== "owner" && role !== "platform_admin") return res.status(403).send("Forbidden");
  next();
}

app.get("/", (req, res) => {
  res.redirect("/dashboard");
});

app.get("/login", (req, res) => {
  res.render("login", { error: null, baseUrl: APP_BASE_URL });
});

app.post("/login", async (req, res) => {
  const { email, password } = req.body;
  const { rows } = await pool.query("select id, email, password_hash, role from users where email=$1", [email]);
  if (!rows.length) return res.render("login", { error: "Invalid credentials", baseUrl: APP_BASE_URL });
  const ok = await bcrypt.compare(password, rows[0].password_hash);
  if (!ok) return res.render("login", { error: "Invalid credentials", baseUrl: APP_BASE_URL });
  req.session.user = { id: rows[0].id, email: rows[0].email, role: rows[0].role };
  res.redirect("/dashboard");
});

app.post("/logout", (req, res) => {
  req.session.destroy(() => res.redirect("/login"));
});

app.get("/dashboard", requireAuth, async (req, res) => {
  res.render("dashboard", { user: req.session.user, baseUrl: APP_BASE_URL });
});

app.get("/admin/settings/integrations", requireAdmin, async (req, res) => {
  const { rows } = await pool.query("select * from app_settings where id=true");
  const s = rows[0];
  res.render("integrations", {
    user: req.session.user,
    baseUrl: APP_BASE_URL,
    settings: {
      discord_client_id: s.discord_client_id || "",
      discord_enabled: s.discord_enabled,
      discord_has_secret: !!s.discord_client_secret_enc,
      ptero_url: s.ptero_url || "",
      ptero_enabled: s.ptero_enabled,
      ptero_has_key: !!s.ptero_app_api_key_enc
    },
    flash: null
  });
});

app.post("/admin/settings/integrations", requireAdmin, async (req, res) => {
  const fieldsChanged = [];
  const discord_client_id = (req.body.discord_client_id || "").trim() || null;
  const discord_enabled = req.body.discord_enabled === "on";
  const discord_client_secret = (req.body.discord_client_secret || "").trim();

  const ptero_url = (req.body.ptero_url || "").trim() || null;
  const ptero_enabled = req.body.ptero_enabled === "on";
  const ptero_app_api_key = (req.body.ptero_app_api_key || "").trim();

  const { rows } = await pool.query("select * from app_settings where id=true");
  const cur = rows[0];

  let discord_secret_enc = cur.discord_client_secret_enc;
  if (discord_client_secret && discord_client_secret !== "••••••••••••") {
    discord_secret_enc = encryptSecret(discord_client_secret);
    fieldsChanged.push("discord_client_secret");
  }
  if ((cur.discord_client_id || null) !== discord_client_id) fieldsChanged.push("discord_client_id");
  if (cur.discord_enabled !== discord_enabled) fieldsChanged.push("discord_enabled");

  let ptero_key_enc = cur.ptero_app_api_key_enc;
  if (ptero_app_api_key && ptero_app_api_key !== "••••••••••••") {
    ptero_key_enc = encryptSecret(ptero_app_api_key);
    fieldsChanged.push("ptero_app_api_key");
  }
  if ((cur.ptero_url || null) !== ptero_url) fieldsChanged.push("ptero_url");
  if (cur.ptero_enabled !== ptero_enabled) fieldsChanged.push("ptero_enabled");

  // Basic validation
  if (discord_enabled && (!discord_client_id || !discord_secret_enc)) {
    return res.status(400).send("Discord enabled but missing Client ID/Secret.");
  }
  if (ptero_enabled && (!ptero_url || !ptero_key_enc)) {
    return res.status(400).send("Pterodactyl enabled but missing Panel URL/API key.");
  }

  await pool.query(
    `update app_settings set
      discord_client_id=$1,
      discord_client_secret_enc=$2,
      discord_enabled=$3,
      ptero_url=$4,
      ptero_app_api_key_enc=$5,
      ptero_enabled=$6,
      updated_at=now(),
      updated_by_user_id=$7
     where id=true`,
    [discord_client_id, discord_secret_enc, discord_enabled, ptero_url, ptero_key_enc, ptero_enabled, req.session.user.id]
  );

  if (fieldsChanged.length) {
    await pool.query(
      "insert into audit_log (actor_user_id, action, fields_changed) values ($1,'settings.update',$2)",
      [req.session.user.id, fieldsChanged]
    );
  }
  res.redirect("/admin/settings/integrations");
});

app.post("/admin/test/pterodactyl", requireAdmin, async (req, res) => {
  const { rows } = await pool.query("select ptero_url, ptero_app_api_key_enc from app_settings where id=true");
  const s = rows[0];
  if (!s.ptero_url || !s.ptero_app_api_key_enc) return res.status(400).json({ ok: false, error: "Missing Pterodactyl settings." });

  const key = decryptSecret(s.ptero_app_api_key_enc);
  try {
    const url = new URL("/api/application/locations", s.ptero_url);
    const r = await fetch(url, {
      headers: { "Authorization": `Bearer ${key}`, "Accept": "application/json" }
    });
    const body = await r.json().catch(() => ({}));
    if (!r.ok) return res.status(400).json({ ok: false, status: r.status, error: body?.errors?.[0]?.detail || "Request failed" });
    const count = Array.isArray(body?.data) ? body.data.length : null;
    return res.json({ ok: true, locations: count });
  } catch (e) {
    return res.status(500).json({ ok: false, error: "Connection error." });
  }
});

// Simple health
app.get("/healthz", (_req, res) => res.json({ ok: true }));

// Views (inline minimal templates)
app.get("/_assets/app.css", (_req, res) => {
  res.type("text/css").send(`
  body{font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; margin:0; background:#0b1220; color:#e6eefc;}
  .wrap{max-width:980px;margin:0 auto;padding:20px;}
  .card{background:#101b33;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:16px;margin:12px 0;}
  .row{display:flex;gap:12px;flex-wrap:wrap;}
  .col{flex:1;min-width:260px;}
  label{display:block;margin:10px 0 6px; opacity:.9;}
  input{width:100%;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#0b1220;color:#e6eefc;}
  .btn{display:inline-block;padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,.16);background:#172a52;color:#e6eefc;cursor:pointer;text-decoration:none;}
  .btn:hover{background:#1b3161;}
  .top{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;}
  .muted{opacity:.75;font-size:14px;}
  .badge{padding:4px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.16);font-size:12px;}
  `);
});

app.listen(3000, () => console.log("Dashboard listening on :3000"));
EOF

  mkdir -p "${INSTALL_DIR}/app/views"
  cat > "${INSTALL_DIR}/app/views/login.ejs" <<'EOF'
<!doctype html><html><head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/_assets/app.css">
<title>Login</title></head>
<body><div class="wrap">
  <div class="card">
    <div class="top">
      <h2 style="margin:0">Vortex Dashboard</h2>
      <span class="muted"><%= baseUrl %></span>
    </div>
    <% if (error) { %><p style="color:#ffb4b4"><%= error %></p><% } %>
    <form method="post" action="/login">
      <label>Email</label><input name="email" autocomplete="username" required>
      <label>Password</label><input name="password" type="password" autocomplete="current-password" required>
      <div style="margin-top:12px"><button class="btn" type="submit">Sign in</button></div>
    </form>
  </div>
</div></body></html>
EOF

  cat > "${INSTALL_DIR}/app/views/dashboard.ejs" <<'EOF'
<!doctype html><html><head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/_assets/app.css">
<title>Dashboard</title></head>
<body><div class="wrap">
  <div class="card">
    <div class="top">
      <div>
        <h2 style="margin:0">Dashboard</h2>
        <div class="muted">Signed in as <%= user.email %> (<%= user.role %>)</div>
      </div>
      <form method="post" action="/logout"><button class="btn" type="submit">Logout</button></form>
    </div>
  </div>

  <div class="row">
    <div class="col">
      <div class="card">
        <h3 style="margin-top:0">Admin</h3>
        <p class="muted">Configure Discord and Pterodactyl credentials here.</p>
        <a class="btn" href="/admin/settings/integrations">Settings → Integrations</a>
      </div>
    </div>
    <div class="col">
      <div class="card">
        <h3 style="margin-top:0">Provisioning</h3>
        <p class="muted">Worker scaffold is deployed. Next step is wiring plans/payments and “Create Server” jobs.</p>
      </div>
    </div>
  </div>
</div></body></html>
EOF

  cat > "${INSTALL_DIR}/app/views/integrations.ejs" <<'EOF'
<!doctype html><html><head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/_assets/app.css">
<title>Integrations</title></head>
<body><div class="wrap">
  <div class="card">
    <div class="top">
      <div>
        <h2 style="margin:0">Settings → Integrations</h2>
        <div class="muted">Admin-only credentials management (encrypted at rest)</div>
      </div>
      <div class="row" style="gap:8px">
        <a class="btn" href="/dashboard">Back</a>
        <form method="post" action="/logout"><button class="btn" type="submit">Logout</button></form>
      </div>
    </div>
  </div>

  <form class="card" method="post" action="/admin/settings/integrations">
    <h3 style="margin-top:0">Discord OAuth</h3>
    <div class="row">
      <div class="col">
        <label>Client ID</label>
        <input name="discord_client_id" value="<%= settings.discord_client_id %>">
      </div>
      <div class="col">
        <label>Client Secret</label>
        <input name="discord_client_secret" value="<%= settings.discord_has_secret ? "••••••••••••" : "" %>">
      </div>
    </div>
    <label style="margin-top:12px">
      <input type="checkbox" name="discord_enabled" <%= settings.discord_enabled ? "checked" : "" %>> Enable Discord login (requires ID + Secret)
    </label>
    <div class="muted" style="margin-top:8px">Redirect URI: <%= baseUrl %>/api/auth/discord/callback (placeholder; OAuth flow wiring comes next)</div>

    <hr style="border:0;border-top:1px solid rgba(255,255,255,.10);margin:16px 0">

    <h3 style="margin-top:0">Pterodactyl</h3>
    <div class="row">
      <div class="col">
        <label>Panel URL</label>
        <input name="ptero_url" placeholder="https://panel.example.com" value="<%= settings.ptero_url %>">
      </div>
      <div class="col">
        <label>Application API Key</label>
        <input name="ptero_app_api_key" value="<%= settings.ptero_has_key ? "••••••••••••" : "" %>">
      </div>
    </div>
    <label style="margin-top:12px">
      <input type="checkbox" name="ptero_enabled" <%= settings.ptero_enabled ? "checked" : "" %>> Enable Pterodactyl backend (requires URL + API key)
    </label>

    <div style="margin-top:14px" class="row">
      <button class="btn" type="submit">Save</button>
      <button class="btn" type="button" onclick="testPtero()">Test Pterodactyl Connection</button>
      <span id="testOut" class="muted" style="align-self:center"></span>
    </div>
  </form>

<script>
async function testPtero() {
  const out = document.getElementById('testOut');
  out.textContent = 'Testing...';
  try {
    const r = await fetch('/admin/test/pterodactyl', { method: 'POST' });
    const j = await r.json();
    out.textContent = j.ok ? `OK (locations: ${j.locations ?? 'n/a'})` : `FAIL: ${j.error ?? 'unknown'} (${j.status ?? ''})`;
  } catch (e) {
    out.textContent = 'FAIL: connection error';
  }
}
</script>
</div></body></html>
EOF

  # Worker scaffold
  cat > "${INSTALL_DIR}/worker/package.json" <<'EOF'
{
  "name": "vortex-mc-worker",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "start": "node worker.js"
  },
  "dependencies": {
    "pg": "^8.12.0",
    "redis": "^4.6.14"
  }
}
EOF

  cat > "${INSTALL_DIR}/worker/Dockerfile" <<'EOF'
FROM node:20-alpine
WORKDIR /worker
COPY package.json package-lock.json* ./
RUN npm install --omit=dev
COPY . .
CMD ["npm","run","start"]
EOF

  cat > "${INSTALL_DIR}/worker/worker.js" <<'EOF'
import { Pool } from "pg";
import { createClient } from "redis";
import crypto from "crypto";

const DATABASE_URL = process.env.DATABASE_URL;
const REDIS_URL = process.env.REDIS_URL;
const SETTINGS_MASTER_KEY_B64 = process.env.SETTINGS_MASTER_KEY;

if (!DATABASE_URL || !REDIS_URL || !SETTINGS_MASTER_KEY_B64) {
  console.error("Missing env vars.");
  process.exit(1);
}

const masterKey = Buffer.from(SETTINGS_MASTER_KEY_B64, "base64");
const pool = new Pool({ connectionString: DATABASE_URL });
const redis = createClient({ url: REDIS_URL });
await redis.connect();

console.log("Worker started. (Scaffold)");

// Minimal job loop scaffold (replace with BullMQ later if desired)
while (true) {
  try {
    // Placeholder: in next iteration we’ll pull jobs from a real queue and call Pterodactyl
    await new Promise(r => setTimeout(r, 10000));
  } catch (e) {
    console.error("Worker loop error:", e?.message || e);
    await new Promise(r => setTimeout(r, 2000));
  }
}
EOF

  log "File generation complete."
}

start_stack() {
  log "Starting stack with Docker Compose..."
  cd "${INSTALL_DIR}"
  docker compose build --no-cache
  docker compose up -d
}

print_next_steps() {
  local domain="${1:-$DOMAIN_DEFAULT}"
  log "Install complete."
  echo
  echo "Next steps:"
  echo "1) Ensure DNS A record points to this server:"
  echo "   dashboard.vortexhosting.onl  ->  <THIS_SERVER_PUBLIC_IP>"
  echo "2) Wait for TLS issuance (Caddy). Then open:"
  echo "   https://${domain}/login"
  echo "3) Retrieve the one-time admin password from app logs:"
  echo "   cd ${INSTALL_DIR} && docker compose logs -n 200 app | sed -n '/INITIAL ADMIN CREATED/,+6p'"
  echo "4) In the dashboard go to: Admin -> Settings -> Integrations"
  echo "   - Paste Pterodactyl Panel URL + Application API Key"
  echo "   - Add Discord Client ID/Secret (optional for now)"
  echo
  echo "Operational commands:"
  echo "  cd ${INSTALL_DIR}"
  echo "  docker compose ps"
  echo "  docker compose logs -f app"
  echo "  docker compose logs -f worker"
}

main() {
  require_root
  require_ubuntu_2204

  local domain="${DOMAIN_DEFAULT}"
  # Allow overriding domain via env var DOMAIN=...
  if [[ -n "${DOMAIN:-}" ]]; then domain="${DOMAIN}"; fi

  install_packages
  install_docker
  configure_firewall
  write_files "${domain}"
  start_stack
  print_next_steps "${domain}"
}

main "$@"
